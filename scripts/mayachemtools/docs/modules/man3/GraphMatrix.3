.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GraphMatrix 1"
.TH GraphMatrix 1 "2018-05-15" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GraphMatrix
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Graph::GraphMatrix;
.PP
use Graph::GraphMatrix qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBGraphMatrix\fR class provides the following methods:
.PP
new, GenerateAdjacencyMatrix, GenerateAdmittanceMatrix, GenerateDegreeMatrix,
GenerateDistanceMatrix, GenerateIncidenceMatrix, GenerateKirchhoffMatrix,
GenerateLaplacianMatrix, GenerateNormalizedLaplacianMatrix,
GenerateSiedelAdjacencyMatrix, GetColumnIDs, GetMatrix, GetMatrixType, GetRowIDs,
StringifyGraphMatrix
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&    $NewGraphMatrix = new Graph::GraphMatrix($Graph);
.Ve
.Sp
Using specified \fIGraph\fR, \fBnew\fR method creates a new \fBGraphMatrix\fR and returns
newly created \fBGraphMatrix\fR.
.IP "\fBGenerateAdjacencyMatrix\fR" 4
.IX Item "GenerateAdjacencyMatrix"
.Vb 1
\&    $AdjacencyGraphMatrix = $GraphMatrix\->GenerateAdjacencyMatrix();
.Ve
.Sp
Generates a new \fIAdjacencyGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fIAdjacencyGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the adjacency matrix for G is a n x n square matrix and
its elements Mij are:
.Sp
.Vb 3
\&    . 0    if i == j
\&    . 1    if i != j and vertex Vi is adjacent to vertex Vj
\&    . 0    if i != j and vertex Vi is not adjacent to vertex Vj
.Ve
.IP "\fBGenerateAdmittanceMatrix\fR" 4
.IX Item "GenerateAdmittanceMatrix"
.Vb 1
\&    $AdmittanceGraphMatrix = $GraphMatrix\->GenerateAdmittanceMatrix();
.Ve
.Sp
Generates a new \fIAdmittanceGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fIAdmittanceGraphMatrix\fR.
.Sp
\&\fBAdmittanceMatrix\fR is another name for \fBLaplacianMatrix\fR.
.IP "\fBGenerateDegreeMatrix\fR" 4
.IX Item "GenerateDegreeMatrix"
.Vb 1
\&    $DegreeGraphMatrix = $GraphMatrix\->GenerateDegreeMatrix();
.Ve
.Sp
Generates a new \fIDegreeGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fIDegreeGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the degree matrix for G is a n x n square matrix and
its elements Mij are:
.Sp
.Vb 2
\&    . deg(Vi)   if i == j and deg(Vi) is the degree of vertex Vi
\&    . 0         otherwise
.Ve
.IP "\fBGenerateDistanceMatrix\fR" 4
.IX Item "GenerateDistanceMatrix"
.Vb 1
\&    $DistanceGraphMatrix = $GraphMatrix\->GenerateDistanceMatrix();
.Ve
.Sp
Generates a new \fIDistanceGraphMatrix\fR for specified \fBGraph\fR using Floyd-Marshall
algorithm [Ref 67] and returns \fIDistanceGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the distance matrix for G is a n x n square matrix and
its elements Mij are:
.Sp
.Vb 2
\&    . 0    if i == j
\&    . d    if i != j and d is the shortest distance between vertex Vi and vertex Vj
.Ve
.Sp
In the final matrix, value of constant \fBBigNumber\fR defined in \fBConstants.pm\fR module
corresponds to vertices with no edges.
.IP "\fBGenerateIncidenceMatrix\fR" 4
.IX Item "GenerateIncidenceMatrix"
.Vb 1
\&    $IncidenceGraphMatrix = $GraphMatrix\->GenerateIncidenceMatrix();
.Ve
.Sp
Generates a new \fIIncidenceGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fIIncidenceGraphMatrix\fR.
.Sp
For a simple graph G with n vertices and e edges, the incidence matrix for G is a n x e matrix
its elements Mij are:
.Sp
.Vb 2
\&    . 1    if vertex Vi and the edge Ej are incident; in other words, Vi and Ej are related
\&    . 0    otherwise
.Ve
.IP "\fBGenerateKirchhoffMatrix\fR" 4
.IX Item "GenerateKirchhoffMatrix"
.Vb 1
\&    $KirchhoffGraphMatrix = $GraphMatrix\->GenerateKirchhoffMatrix();
.Ve
.Sp
Generates a new \fIKirchhoffGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fIKirchhoffGraphMatrix\fR.
.Sp
\&\fBKirchhoffMatrix\fR is another name for \fBLaplacianMatrix\fR.
.IP "\fBGenerateLaplacianMatrix\fR" 4
.IX Item "GenerateLaplacianMatrix"
.Vb 1
\&    $LaplacianGraphMatrix = $GraphMatrix\->GenerateLaplacianMatrix();
.Ve
.Sp
Generates a new \fILaplacianGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fILaplacianGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the Laplacian matrix for G is a n x n square matrix and
its elements Mij are:
.Sp
.Vb 3
\&    . deg(Vi)   if i == j and deg(Vi) is the degree of vertex Vi
\&    . \-1        if i != j and vertex Vi is adjacent to vertex Vj
\&    . 0         otherwise
.Ve
.Sp
The Laplacian matrix is the difference between the degree matrix and adjacency matrix.
.IP "\fBGenerateNormalizedLaplacianMatrix\fR" 4
.IX Item "GenerateNormalizedLaplacianMatrix"
.Vb 1
\&    $NormalizedLaplacianGraphMatrix = $GraphMatrix\->GenerateNormalizedLaplacianMatrix();
.Ve
.Sp
Generates a new \fINormalizedLaplacianGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fINormalizedLaplacianGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the normalized Laplacian matrix L for G is a n x n square
matrix and its elements Lij are:
.Sp
.Vb 3
\&    .  1                           if i == j and deg(Vi) != 0
\&    .  \-1/SQRT(deg(Vi) * deg(Vj))  if i != j and vertex Vi is adjacent to vertex Vj
\&    .  0                           otherwise
.Ve
.IP "\fBGenerateSiedelAdjacencyMatrix\fR" 4
.IX Item "GenerateSiedelAdjacencyMatrix"
.Vb 1
\&    $SiedelAdjacencyGraphMatrix = $GraphMatrix\->GenerateSiedelAdjacencyMatrix();
.Ve
.Sp
Generates a new \fISiedelAdjacencyGraphMatrix\fR for specified \fBGraph\fR and returns
\&\fISiedelAdjacencyGraphMatrix\fR.
.Sp
For a simple graph G with n vertices, the Siedal adjacency matrix for G is a n x n square matrix and
its elements Mij are:
.Sp
.Vb 3
\&    . 0    if i == j
\&    . \-1   if i != j and vertex Vi is adjacent to vertex Vj
\&    . 1    if i != j and vertex Vi is not adjacent to vertex Vj
.Ve
.IP "\fBGetColumnIDs\fR" 4
.IX Item "GetColumnIDs"
.Vb 1
\&    @ColumnIDs = $GraphMatrix\->GetColumnIDs();
.Ve
.Sp
Returns an array containing any specified column IDs for \fIGraphMatrix\fR.
.IP "\fBGetMatrix\fR" 4
.IX Item "GetMatrix"
.Vb 1
\&    $Matrix = $GraphMatrix\->GetMatrix();
.Ve
.Sp
Returns \fIMatrix\fR object corresponding to \fIGraphMatrix\fR object.
.IP "\fBGetMatrixType\fR" 4
.IX Item "GetMatrixType"
.Vb 1
\&    $MatrixType = $GraphMatrix\->GetMatrixType();
.Ve
.Sp
Returns \fBMatrixType\fR of \fIGraphMatrix\fR.
.IP "\fBGetRowIDs\fR" 4
.IX Item "GetRowIDs"
.Vb 1
\&    @RowIDs = $GraphMatrix\->GetRowIDs();
.Ve
.Sp
Returns an array containing any specified rowIDs IDs for \fIGraphMatrix\fR.
.IP "\fBStringifyGraphMatrix\fR" 4
.IX Item "StringifyGraphMatrix"
.Vb 1
\&    $String = $GraphMatrix\->StringifyGraphMatrix();
.Ve
.Sp
Returns a string containing information about \fIGraphMatrix\fR object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Constants.pm, Graph.pm, Matrix.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2018 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
